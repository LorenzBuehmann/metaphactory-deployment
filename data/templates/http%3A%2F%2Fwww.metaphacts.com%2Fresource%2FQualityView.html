<h2>Validate imports against archived ontologies</h2>
<p>Ontology: <code>{{{resource}}}</code></p>

<button id="recomputeAndValidate" class="btn btn-primary">
  Recompute “importsArchived” & run Data Quality
</button>

<!-- 1) Button click → run the SPARQL UPDATE -->
<mp-event-proxy
  on-event-source="recomputeAndValidate"
  on-event-type="click"
  proxy-event-type="SemanticUpdate.Execute"
  proxy-targets='["update-archived-helpers"]'>
</mp-event-proxy>

<!-- SPARQL UPDATE: build helper triples into THIS ontology's graph -->
<semantic-update
  id="update-archived-helpers"
  show-confirmation="false"
  redirect="event"
  query="
PREFIX owl:  <http://www.w3.org/2002/07/owl#>
PREFIX bibo: <http://purl.org/ontology/bibo/>
PREFIX pso:  <http://purl.org/spar/pso/>
PREFIX qa:   <urn:qa:>

# Assumes graph IRI == ontology IRI. If not, bind ?g differently (see note below).
DELETE { GRAPH ?g { <{{{resource}}}> qa:importsArchived ?o . } }
INSERT { GRAPH ?g { <{{{resource}}}> qa:importsArchived ?o . } }
WHERE  {
  BIND(IRI('{{{resource}}}') AS ?this)
  BIND(?this AS ?g)
  GRAPH ?g { ?this a owl:Ontology ; owl:imports ?o . }
  GRAPH ?o { ?o bibo:status pso:archived . }
}">
</semantic-update>

<!-- 2) After UPDATE → call Data Quality job (plain fetch; no extra component needed) -->
<script>
  async function runDQ(iri) {
    const res = await fetch('/rest/jobs/data-quality/run', {
      method: 'POST',
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: JSON.stringify({
        configurationId: 'ontologies-checks',     // ← adjust to your Data Quality config id
        scope: { semanticContext: 'ontologies-union' }, // ← adjust to your context name
        labels: { resource: iri }
      })
    });
    if (!res.ok) throw new Error('Data Quality job failed: ' + res.status);
    return res.json();
  }

  // Chain: UPDATE success → run DQ
  addEventListener('SemanticUpdate.Success', async () => {
    try {
      const iri = '{{{resource}}}';
      const job = await runDQ(iri);
      console.log('Data Quality run started:', job);
      alert('Helper triples rebuilt and Data Quality run started.');
    } catch (err) {
      console.error(err);
      alert('Failed to start Data Quality: ' + (err.message || err));
    }
  });

  addEventListener('SemanticUpdate.Failed', (e) => {
    console.warn('Helper update failed', e.detail || e);
    alert('SPARQL UPDATE failed. See console for details.');
  });
</script>

<!-- 3) (Optional) Show the helper triples so you see it worked -->
<semantic-query
  id="qa-check"
  query="
PREFIX qa: <urn:qa:>
SELECT ?o WHERE { GRAPH <{{{resource}}}> { <{{{resource}}}> qa:importsArchived ?o . } }"
  template="table">
</semantic-query>

<!-- Refresh the table after the UPDATE -->
<mp-event-proxy
  on-event-source="update-archived-helpers"
  on-event-type="SemanticUpdate.Success"
  proxy-event-type="Component.Refresh"
  proxy-targets='["qa-check"]'>
</mp-event-proxy>
